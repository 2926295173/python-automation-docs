
`Innodb` 和 `Myisam` 引擎的实现

`Mysql` 底层数据引擎以插件形式设计，最常见的是 `Innodb` 引擎和 `Myisam` 引擎，用户可以根据个人需求选择不同的引擎作为 `Mysql` 数据表的底层引擎。我们刚分析了，`B+树`作为 `Mysql` 的索引的数据结构非常合适，但是数据和索引到底怎么组织起来也是需要一番设计，设计理念的不同也导致了 `Innodb` 和 `Myisam` 的出现，各自呈现独特的性能。

`MyISAM` 虽然数据查找性能极佳，但是不支持事务处理。`Innodb` 最大的特色就是支持了 `ACID` 兼容的事务功能，而且他支持行级锁。`Mysql` 建立表的时候就可以指定引擎，比如下面的例子，就是分别指定了 `Myisam` 和 `Innodb` 


执行这两个指令后，系统出现了以下的文件，说明这两个引擎数据和索引的组织方式是不一样的。

`Innodb` 创建表后生成的文件有：

- `frm`:创建表的语句
- `idb`:表里面的数据+索引文件
- `Myisam` 创建表后生成的文件有

`MyISAM` 创建表后生成的文件有：
- `frm`:创建表的语句
- `MYD`:表里面的数据文件（myisam data）
- `MYI`:表里面的索引文件（myisam index）

![](https://pic2.zhimg.com/80/v2-8a065d6e21a2adbf06d2e6b5dd02e969_1440w.jpg)

从生成的文件看来，这两个引擎底层数据和索引的组织方式并不一样，`MyISAM` 引擎把数据和索引分开了，一人一个文件，这叫做非聚集索引方式；`Innodb` 引擎把数据和索引放在同一个文件里了，这叫做`聚集索引`方式。下面将从底层实现角度分析这两个引擎是怎么依靠 `B+树`这个数据结构来组织引擎实现的。

`MyISAM` 引擎的底层实现（`非聚集索引`方式）
`MyISAM` 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。`MyISAM` 在建表时以`主键`作为 KEY 来建立主索引 `B+树`，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 `MyISAM` 数据文件中直接定位到具体的数据记录了。

![](https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_1440w.jpg)


当我们为某个字段添加索引时，我们同样会生成对应字段的索引树，该字段的索引树的叶子节点同样是记录了对应数据的物理地址，然后也是拿着这个物理地址去数据文件里定位到具体的数据记录。

`Innodb` 引擎的底层实现（`聚集索引`方式）
`InnoDB` 是聚集索引方式，因此数据和索引都存储在同一个文件里。首先 `Inno`DB 会根据`主键` ID 作为 KEY 建立索引 `B+树`，如左下图所示，而 `B+树`的叶子节点存储的是主键 ID 对应的数据，

比如在执行 `select * from user_info where id=15 `这个语句时，`InnoDB` 就会查询这颗`主键` ID 索引 `B+树`，找到对应的 `user_name='Bob'`。

这是建表的时候 `InnoDB` 就会自动建立好`主键` ID 索引树，这也是为什么 `Mysql` 在建表时要求必须指定主键的原因。当我们为表里某个字段加索引时 `InnoDB` 会怎么建立索引树呢？比如我们要给 `user_name` 这个字段加索引，那么 `InnoDB` 就会建立 `user_name` 索引` B+树`，节点里存的是 `user_name` 这个 KEY，叶子节点存储的数据的是主键 KEY。注意，叶子存储的是主键 KEY！拿到主键 KEY 后，`InnoDB` 才会去主键索引树里根据刚在 `user_name` 索引树找到的`主键` KEY 查找到对应的数据。

![](https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_1440w.jpg)


问题来了，为什么 `InnoDB` 只在主键索引树的叶子节点存储了具体数据，但是其他索引树却不存具体数据呢，而要多此一举先找到主键，再在主键索引树找到对应的数据呢?

其实很简单，因为 `InnoDB` 需要节省存储空间。一个表里可能有很多个索引，`InnoDB` 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据`极度冗余`了）。从节约磁盘空间的角度来说，真的没有必要每个字段索引树都存具体数据，通过这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，这是非常有值得的。

在进行 `InnoDB` 和 `MyISAM` 特点对比时谈到，`MyISAM` 查询性能更好，从上面索引文件数据文件的设计来看也可以看出原因：MyISAM 直接找到物理地址后就可以直接定位到数据记录，但是 `InnoDB` 查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。等于 `MyISAM` 一步就查到了数据，但是 `InnoDB` 要两步，那当然 `MyISAM` 查询性能更高。

本文首先探讨了哪种数据结构更适合作为 `Mysql` 底层索引的实现，然后再介绍了 `Mysql` 两种经典数据引擎 `MyISAM` 和 `InnoDB` 的底层实现。最后再总结一下什么时候需要给你的表里的字段加索引吧：

- 较频繁的作为查询条件的字段应该创建索引；
- 唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；
- 更新非常频繁的字段不适合创建索引








### 存储引擎比较 

四．四种存储引擎比较

`InnoDB`：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。

`MyISAM`：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率

`MEMORY`：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

`Archive`：如果只有INSERT和SELECT操作，可以选择`Archive`，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archiv

注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。




